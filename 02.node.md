# 1.服务端开发基础

## 1.1 Web开发入门

```javascript
前端开发最终还是属于 Web 开发中的一个分支，想要成为一名合格的前端开发人员，就必须要充分理解Web的概念。

//Web服务软件分为两种
//1. C/S (Client - Server  客户端-服务器端)
典型应用：QQ软件 ，飞秋，红蜘蛛。
特点：
1）必须下载特定的客户端程序。
2）服务器端升级，客户端升级。

//2. B/S （Broswer -Server 浏览器端- 服务器端）
典型应用： 腾讯官方（www.qq.com）  163新闻网站， 
特点：
1）不需要安装特定的客户端（只需要安装浏览器即可！！）
2）服务器端升级，浏览器不需要升级！！！！
```

## 1.2 之前学习了什么

	在之前的学习过程中，我们很专注，没有关心这些东西在整体中是什么角色，起到什么作用。这里我们是时候总结一下我们之前学过了的内容：

```javascript
网页开发技术（硬性）

HTML —— 网页内容结构（GUI）
CSS —— 网页外观样式（GUI）
JavaScript —— 编程语言（可以用于调用浏览器提供的 API）

Web APIs —— 网页交互（界面功能）
jQuery —— 便捷手段（糖果而已，不是必要的）
编程能力 / 编程思想 / 解决问题的思路（软性）
```

    至此，我们已经可以独立完成网页开发了，具体能完成的东西就是一个一个的网页，而且还能给这个页面加上一些动态的交互。但是这距离成为一个网站还有一些路要走。

## 1.3 还需要学习什么

	想要完成完整的 Web 网站，还需要学习什么？

```
搭建 WEB 服务器（提供网站服务的机器）
HTTP（浏览器与服务端的通讯协议）
服务端开发（动态网页技术）
数据库操作（服务端存储数据方式）
AJAX（浏览器与服务端的数据交互方式）
```

## 1.4 网络基础概念

### 1.4.1 IP介绍

	设备在某一个网络中的地址，目前最常见的格式： [0-255].[0-255].[0-255].[0-255] 即为四个 0-255 的数字组
成。
	IP作用就是标识一个网络设备（计算机、手机、电视）在某一个具体的网络当中的地址。

```javascript
//IP4地址：IP地址本质上是一个由32位的二进制数组成的数据。后来为了方便记忆，就把IP4地址切成了4份，每份是8位。
00000000-00000000-00000000-00000000  
2^8 – 2^8 -2^8 -2^8，大概42亿个，其中30亿在北美，亚洲4亿。2011年初已经用尽。

//IP6 ：是一个由128位二进制数组成的数据

Ipconfig ：查看本机ip ，192.168.10．1
Ping www.baidu.com  ：查看能否连接百度
127.0.0.1 是本地回环地址
```

#### a) 局域网IP 地址

	在单个局域网下，结构非常简单，就是我们所连接的网络设备（网关）给我们分配了一个地址，在这个范围之内我们都可以通过这个地址找到我们的这个设备。

> 如果设备没有连接任何网络情况下，我们会有一个本地回环地址 127.0.0.1

![](media/p7.png)

#### b) 公网IP地址

	IP是互联网的唯一定位地址，作用相当于门牌号，比如有2000台电脑，电脑通过[路由交换机](https://www.baidu.com/s?wd=%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E6%9C%BA&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)形成一个局域网，就像一个大楼，大楼内部找人，有301室，302室。但是对外面的人来说，是无法进行、获取到内部地址的，她们找查找的时候只能找到XX大楼，大楼的大门号就相当于[公网IP](https://www.baidu.com/s?wd=%E5%85%AC%E7%BD%91IP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)
	
	所以同一个路由器交换机下的公网ip都是一致的。同一wifi下算是组建了一个小型局域网，路由器算作一个网关，路由器将有唯一的IP对外网进行转发传输，而外网数据在到达路由器后，由于在此局域网的用户IP是唯一的，路由器可以轻松进行进一步ARP地址匹配数据包进行连接传输，每位用户在路由器内部拥有唯一的ARP指向区，不会造成混乱。

![](media/ip01.png)

### 1.4.2. 域名

	由于 IP 地址都是没有规律的一些数字组成的，很难被人记住，不利于广泛传播，所以就有人想出来要给 IP 起名字（别名）。

> 域名是需要花钱注册的

### 1.4.3. DNS与Hosts文件

	通过宽带运营商提供的服务器解析一个域名背后对应的 IP，这个过程叫做 DNS 寻址，帮你完成 DNS 寻址过程的服务器叫做 DNS 服务器。
	
	DNS寻址过程：浏览器--->操作系统缓存---->本机hosts文件--->DNS服务器
	
	操作系统在发起对 DNS 服务器的查询请求之前，会优先检查浏览器缓存的DNS和本机的 hosts 文件。如果有包含了对当前需要解析的域名的配置，则不再发起对 DNS 服务器的请求，直接使用浏览器缓存或者本机hosts文件中的配置。

```javascript
//1.浏览器缓存中DNS查看
chrome://net-internals/#dns

//2.hosts文件所在路径：
Windows： C:\Windows\System32\drivers\etc\hosts
macOS： /etc/hosts

//3.注意：
本机的 hosts 文件配置只能到影响本机的 DNS 寻址
只有以管理员权限运行的编辑器才有权利修改 hosts 文件

//4.常用DNS服务器
北京联通      202.106.0.20  	202.106.196.115
阿里          223.5.5.5  223.6.6.6              
114          114.114.114.114   
//114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS
南方电信      180.153.225.136
百度          180.76.76.76                 
360          101.226.4.5
谷歌          8.8.8.8                
```

![](media/d10.png)

### 1.4.4. 端口

	计算机本身是一个封闭的环境，就像是一个大楼，如果需要有数据通信往来，必须有门，这个门在术语中就叫端口。
	
	端口号是每个应用程序在终端设备上的唯一标识。

> 一般我们把“占门”的过程叫做监听

```javascript
netstat -an                   查看本机端口使用情况
netstat -aon|findstr "80"     查看指定端口的情况
taskkill /pid 4136 -t -f      根据pid杀死指定的进程
```



![](media/p9.png)

```javascript
https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3
https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3

//端口号的取值范围0~65535 ，1024以下端口(0~1023端口)被系统占用，不可以使用。
1024~49151端口是系统绑定的松散服务（其中一些端口是可以使用的）。
49152~65535 是可以使用的端口。

//常用端口：
Mysql:3306
Oracle:1521 
Tomcat:8080
QQ:4000
FeiQ:2425
http:80
https:443
```

### 1.4.5. URL和URI

	URL（Uniform Resource Locator），统一资源定位符，通俗点来说就是表示网络当中某一个网页的完整访问地址，它具有一定的格式：

![](media/p10.png)

	URI：统一资源标识符，用来标识互联网上的资源。

```javascript
1.完全URI的组成： scheme://authority/path?query#fragment。只要满则这个格式的都是URI
2.URI可以分为绝对的URI和相对的URI
  2.1 绝对的URI：需要有完整的格式(除了scheme和authority必须要有，其余可以省略)。其实这边就是URL了。
  2.2 相对的URI：不以scheme开始的非完整格式(比如在网页开发中会用到很多相对URI)。

//URI和URL区别
1.URI类只标识资源,URL类既能标识资源,又能获取资源
2.URL是URI的子集
3.URL具有唯一性
```

## 1.5 搭建 Web 服务器

```
服务器（提供服务）指的就是一台安装特定的软件的公共计算机，用于专门用于提供特定的服务。
按照服务类型的不同，又划分为：Web服务器、数据库服务器、邮件服务器等等。

客户端（使用服务）指的是在一次服务过程中使用这个服务的设备（网络端点）。
目前咱们最常见的客户端就是浏览器
```

	我们手头上的这些网页，如果想要成为一个网站，首先要完成的第一件事就是有一台公共的 Web 服务器，把这一系列的页面放到这台 Web 服务器上，让用户可以通过服务器的地址访问到这些网页

![](media/p1.png)

	我们手头上的电脑都可以是一台服务器，因为服务器是一个相对的概念，只要能提供服务就可以是一个服务器（提供服务的时候就是服务端，使用服务的时候就是客户端）。
	
	既然服务器就是安装特定的软件的计算机，那么要让自己的成为 Web 服务器就是要安装一个 Web 服务器软件。

### 1.5.1  Web 服务器软件介绍

```javascript
//web服务软件的作用：把本地的资源共享给外部访问。

//常用的web服务软件
Apache ······························································· PHP
IIS ···································································ASP.NET
Tomcat(WebLogic/WebSphere/JBoss) ····································· Java
Node ···································································不需要安装软件
```

### 1.5.2 Web服务软件-apache

#### a) apache安装

	这里我们选择一个比较常用的 Web 服务器软件：Apache HTTP Server。

```php
由于最新的 Apache 已经不提供 Windows 的安装版本了，所以我们这里使用的是解压版。

下载地址：https://www.apachelounge.com/download/
使用说明：https://httpd.apache.org/docs/current/platform/windows.html
```

	安装方式如下，先解压到纯英文路径的文件夹，然后执行以下命令：

```javascript
# 注意：需要使用管理员身份运行命令行！！！
# 切换到 Apache 解压路径中的 bin 目录
$ cd <解压目录>/bin
# 安装 Apache 服务，‐n 参数是指定服务名称
$ httpd.exe -k install -n "Apache"
# 如果需要卸载 Apache，可以执行以下命令
$ httpd.exe -k uninstall -n "Apache"
```

	执行安装命令过后会报一个错，原因是默认的配置文件有问题，需要先调整一下配置文件 conf/httpd.conf ，才能正常启动服务。

![](media/p2.png)

	找到 Apache 解压目录中的 conf 目录下的 httpd.conf 文件，定位到 37 行，将 c:/Apache24 改为解压目录，我这里解压到路径是 C:/Develop/apache ，所以我这里修改

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p3.png)

	修改完以后，执行以下命令重新测试配置文件是否通过。

```javascript
$ httpd.exe ‐t
```

	这里任然报错：

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p4.png)

	通过错误信息得知，这里是因为另外一个地方配置的目录不存在导致的，所以接着调整 246 行的 DocumentRoot选项：
![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p5.png)

	随即，我们发现这个配置文件中有很多默认配置选项中的路径都是 c:/Apache24 ，所以我们批量都修改为我们解压的目录路径。
	然后重新执行 httpd.exe -t 测试配置文件，这时候应该提示 Syntax OK 。

> 如果有关于 ServerName 的警告提示，不用管它，暂时还不会影响我们接下来的使用和操作。

	接着运行以下命令重新启动 Apache 服务：

```javascript
# 注意：需要使用管理员身份运行命令行！！！
$ httpd.exe -k start -n "Apache"
# 重新启动 Apache 服务
$ httpd.exe -k restart -n "Apache"
# 停止 Apache 服务
$ httpd.exe -k stop -n "Apache"

```

	回到浏览器中，地址栏输入：http://localhost/，回车访问，这时正常应该看到 It works!

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p6.png)



#### b) 提供 Web 服务

	启动 Apache，让别人可以使用你机器上安装的 Apache 提供的 Web 服务，访问你机器上的网站。这种情况下你的机器就是服务器，别人的机器就是客户端。

```javascript
//注意：
1.确保配置文件语法检查通过
2.确保 80 端口没有被其他程序占用
3.确保防火墙允许 80 端口的请求，或者干脆关掉防火墙
4.如果出现 Forbidden 情况，确保配置文件 httpd.conf 中 247 行（ DocumentRoot 之后）的 Directory 配
置的与 DocumentRoot 路径相同
5.我们在开发阶段大多数都是自己访问自己机器上的网站，那这种情况下，我们既是服务端又是客户端。对于新手来说，最常见的问题就是分不清楚哪是客户端应该有的，哪是服务端应该有的。这种时候一定要保持清醒，客户端局限在浏览器窗口，代码以及 Apache 相关的文件和配置都是放在服务端的
```

#### c) 配置 Apache

```
配置文档：http://httpd.apache.org/docs/current/
配置文件中行首的 # 指的是注释
注意：以下所记录的行号仅供参考，不同版本的配置文件可能不尽相同。
```

##### a. 监听端口

	监听端口可以随意修改为任意一个未被其他程序监听的端口，可以通过设置配置文件 httpd.conf 中的 Listen
指令后面的数字修改。

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p12.png)

##### b. 网站根目录

```php
网站根目录就是存放我们网站文件的最顶层目录，通常 URL 中域名后面的第一个斜线对应（映射）的就是网站根目录。
```

	默认 Apache 的网站根目录是安装目录中的 htdocs 文件夹，为了方便对网站文件的管理，一般我们会将其设置在一个自定义目录中（如果你不介意其实不修改也无所谓）。
	如果需要设置网站根目录，可以通过修改配置文件 httpd.conf 中的网站根目录选项切换。

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p13.png)



##### c. 默认文档

```
当客户端访问的是一个目录而不是具体文件时，服务端默认返回这个目录下的某个文档（文件），这个文档就称之为默认文档。
```

	配置文件 httpd.conf 的 280 行的 DirectoryIndex ，默认文档可以配置多个（有前到后依次去找，找到为止，如果没找到任何一个则启用目录浏览）：

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p14.png)

##### d. 虚拟主机

	如果一台机器上只有一个网站的话，没有任何问题，但是如果想要在一台机器上部署多个站点，就必须通过配置虚拟主机的方式解决。一旦配置虚拟主机之后，**原来的apacke的网站根目录就不能用了**。
	
	由于后期对虚拟主机的配置操作非常常见，所以我们一般将虚拟主机的配置单独放到一个配置文件中，然后
在主配置文件中引入，避免破坏主配置文件中的其他配置。
	Include conf/extra/httpd-vhosts.conf 配置的作用就将另外一个配置文件引入（使其生效）

	具体的操作方式就是在主配置文件 httpd.conf 的 505 行取消注释：

![](D:/%E5%89%8D%E7%AB%AF%E5%A4%87%E8%AF%BE/08.Node/readme/media/p15.png)

	然后找到 Apache 的虚拟主机配置文件，添加一个如下的虚拟主机配置节点，然后重新启动 Apache。

```
这个文件中有两个默认的示例配置，可以注释掉 (Alt+shif+上下箭头)
```

```
<VirtualHost *:8081> 
    DocumentRoot "D:/code"
    ServerName mytest.me
	<Directory "D:/code">
		Options FollowSymLinks Indexes 
		AllowOverride none
		Require all granted
	</Directory>
</VirtualHost>

//这边要使用mytest.me这个域名来访问，需要修改 hosts 文件，原因很简单：这个域名不是我们自己的，我们没有办法修改这个域名在公网上的 DNS
```

**注意：还需要修改httpd.conf中的**

```javascript
<Directory>
   AllowOverride none
   # Require all denied
   Require all granted
</Directory>

//注意
如果使用了虚拟主机，则默认必须全使用虚拟主机，即之前的默认网站也必须通过虚拟主机方式配置，否则访问不到。参考：http://skypegnu1.blog.51cto.com/8991766/1532454

如果虚拟主机的端口使用的不是 80 ，则需要在主配置文件中添加一个对这个端口的监听
```

### 1.5.3 Web服务软件-集成环境

          wamp(windows  apache  mysql  php)
    
      直接点击安装就可以。
    
      默认会访问安装目录下的index.html/index.php	

#### a) 允许所有请求

	在安装目录的apache下面找到httpd.conf文件修改如下。修改之后需要重启apache，别人就可以通过ip来访问当前主机了。
	
	![1537712690593](media/wamp01.png)

#### b) 配置虚拟主机

	有时候我们想要在apache上运行多个站点，这个时候就需要配置虚拟主机
	
	1) 具体的操作方式就是在主配置文件 httpd.conf 的 505 行取消注释：

![](media/p15.png)

	2) 然后找到 Apache 的虚拟主机配置文件，添加一个如下的虚拟主机配置节点(需要确保相关文件夹存在)，然后重新启动 Apache。

```
这个文件中有两个默认的示例配置，可以注释掉 (Alt+shif+上下箭头)


<VirtualHost *:80>
    #绑定域名
    ServerName localhost
    #默认首页
    DirectoryIndex index.html index.php
    #指定网站根目录
    DocumentRoot "E:/wamp/Apache2/htdocs"
    #指定目录分配权限
    <Directory "E:/wamp/Apache2/htdocs">
        #没有首页就显示列表（开发阶段可以这样）取值：all none Index
        Options Indexes
        #规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow
        Order Deny,Allow
        #全部禁止访问 取值：all none 指定ip
        Deny from All
        #但是，允许自己访问  取值：all none 指定ip
        Allow from 127.0.0.1
    </Directory>
</VirtualHost>
```

![](media/wamp03.png)

3) 修改C:\Windows\System32\drivers\etc\hosts配置，需要管理员权限

![](media/wamp04.png)

## 1.6 请求响应流程

 	安装配置完成服务器之后，我们把网页部署到服务器，浏览器通过指定网址访问到的是服务器的资源。这里就是一个简易的网站。

![](media/p11.png)



```
1. 用户打开浏览器
2. 地址栏输入我们需要访问的网站网址（URL）
3. 浏览器通过 DNS 服务器获取即将访问的网站 IP 地址
4. 浏览器发起一个对这个 IP 的请求
5. 服务端接收到这个请求，进行相应的处理
6. 服务端将处理完的结果返回给客户端浏览器
7. 浏览器将服务端返回的结果呈现到界面上
```



# 2.Node介绍

## 2.1 Javascript回顾

	前端全栈工程师 ： 全栈就是全干。全栈：前端、后端。
	
	之前学的javascript是运行在浏览器上的脚本语言。包含三个部分：ECMAScript 、BOM、DOM

## 2.2 初识Nodejs

	Node.js 是一种基于Google的V8引擎的 non-blocking (非阻塞）的event-driven （事件驱动） I/O平台.。简单的说 Node.js 就是运行在服务端的 JavaScript。
	
	Node.js平台使用的开发语言是JavaScript，平台提供了操作系统低层的API，方便做服务器端编程，具体包括文件操作、进程操作、通信操作等系统模块

> 作者Ryan Dahl   瑞恩·达尔
>
> - 2004 纽约 读数学博士 
> - 2006 退学到智利 转向开发 
> - 2009.5对外宣布node项目，年底js大会发表演讲 
> - 2010 加入Joyent云计算公司 
> - 2012 退居幕后

```javascript
# 1.Node.js特点：
①是一个javascript运行环境或者平台(可以解释执行js代码)，不是编程语言也不是js框架
②依赖于Chrome V8引擎进行代码解释
③基于事件驱动
④异步式I/O(非阻塞I/O)
⑤单进程、单线程、基于事件回调
⑥轻量、可伸缩，适用于实时数据交互应用

# 2.Node.js中包含下面内容：
① Ecmascript(没有BOM和DOM)
② 一些服务器级别的API
    文件读写
    网络服务
    网络通信
    http服务器
③ 在Node.js中使用npm包管理工具来下载和管理package 

# 3.关于v8引擎
1.浏览器内核又可以分成两部分：渲染引擎(layout engineer或者RenderingEngine)和JS引擎。
2.渲染引擎:负责对网页语法的解释（如HTML、JavaScript）并渲染网页。当前主流渲染引擎内核：
	a) firefox使用gecko引擎
　   b) IE使用Trident引擎
　   c) 2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge,使用edge引擎
　   d) opera最早使用Presto引擎，后来弃用
　   e) chrome\safari\opera使用webkit引擎
　   f) 13年chrome和opera开始使用Blink引擎
3.JS引擎:最开始渲染引擎和js引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎
	1 ) Mozilla
         Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写。
         SpiderMonkey，第一款JavaScript引擎，由BrendanEich在NetscapeCommunications时编写，用于Mozilla Firefox1.0～3.0版本。
         TraceMonkey，基于实时编译的引擎，其中部份代码取自Tamarin引擎，用于 Mozilla Firefox 3.5～3.6版本。
         JägerMonkey，（JägerMonkey，也有人拼写成JagerMonkey）德文Jäger原意为猎人，结合追踪和组合码技术大幅提高效能，部分技术借凿了V8、JavaScriptCore、WebKit，用于Mozilla Firefox 4.0以上版本。
	2）Google
         V8，开放源代码，由Google丹麦开发，是Google Chrome的一部分。#V8引擎目前最快
	3）微软
         Chakra，中文译名为查克拉，用于Internet Explorer 9。
         JScript 是由微软公司开发的活动脚本语言，是微软对ECMAScript规范的实现.IE 3.0-IE8.0使用的JS引擎
	4）其它
   		KJS，KDE的ECMAScript/JavaScript引擎，最初由Harri Porten开发，用于KDE项目的 Konqueror网页浏览器中。
   		Narcissus，开放源代码，由BrendanEich编写（他也参与编写了第一个SpiderMonkey）。
   		Tamarin，由AdobeLabs编写，Flash Player 9所使用的引擎。
   		Nitro（原名SquirrelFish），为Safari 4编写。
   		Carakan，由Opera软件公司编写，自Opera10.50版本开始使用。
```

## 2.3 Node.js的应用场景	

```javascript
# Node.js适合应用在高并发、I/O密集、少量业务逻辑的场景
	Node.js善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。
	当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。

# Node.js适用场景：
1. 用户表单收集
2. 考试系统
3. 聊天室
4. 图文直播
5. 提供JSON的API（为前台Angular Vue使用）
6. 命令行工具  npm  git  hexo

# Node.js不适合的场景：
1.计算密集型应用(计算密集需要花费大量的CPU资源)
2.单用户多任务的程序  比如360安全卫士
3.逻辑十分复杂的事务  
4.unicode与国际化
```

## 2.4 node.js 学习资料

1. [node.js官方网站](https://nodejs.org/)
2. [node.js中文网](http://nodejs.cn/)
3. [node.js 中文社区](https://cnodejs.org/)
4. 深入浅出Node.js
5. Node.js权威指南
6. cnode社区  https://cnodejs.org

## 2.5.CMD终端基本使用

### 2.5.1 打开应用
```
- notepad 打开记事本
- mspaint 打开画图
- calc 打开计算机
- write 写字板
- sysdm.cpl 打开环境变量设置窗口
```

### 2.5.2 常用命令
```
- md                           创建目录
- rmdir(rd)                  删除目录，目录内没有文档。
- echo on > a.txt        创建空文件
   echo 123 > a.txt      向a.txt写入123 
   echo 456 >> a.txt    向a.txt追加456
- del                            删除文件
- rm 文件名                 删除文件
- cat 文件名                查看文件内容
- cat > 文件名             向文件中写上内容，按住ctrl+c退出
  cat >> 文件名           向文件中追加内容，按住ctrl+c退出
```

## 2.6.Node.js的安装

### 2.6.1 普通安装方式

1. 普通安装方式[官方网站](https://nodejs.org/zh-cn/)
2. 官网：长期支持版(主流版本) 和 当前发布版(含有一些最新功能)
3. 在安装node的时候，如果之前安装过了老版本，会自动覆盖之前的版本
4. 安装node的时候，一定要add path添加环境变量

### 2.6.2 多版本安装方式

1. 卸载已有的Node.js

2. 下载[nvm](https://github.com/coreybutler/nvm-windows) ,下载nvm-noinstall.zip   

3. 在C盘创建目录dev

4. 在dev目中中创建两个子目录nvm和nodejs

5. 并且把nvm包解压进去nvm目录中

6. 在install.cmd文件上面右键选择【以管理员身份运行】

7. 打开的cmd窗口直接回车会生成一个settings.txt文件，将setting.txt保存到当前dev下的nvm下面

    > root: C:\dev\nvm 
    > path: C:\dev\nodejs
    > arch: 64 
    > proxy: none

8. 配置nvm和Node.js环境变量
    > NVM_HOME:C:\dev\nvm
    >
    > NVM_SYMLINK:C:\dev\nodejs

9. 把配置好的两个环境变量加到Path中

     > ;%NVM_HOME%;%NVM_SYMLINK%;

### 2.6.3 nvm常用的命令
- nvm version                        查看nvm版本号
- nvm list                                查看当前安装的Node.js所有版本
- nvm install 10.14.1            安装指定版本的Node.js
- nvm uninstall 版本号         卸载指定版本的Node.js
- nvm use 10.14.1                 选择指定版本的Node.js

# 3.Node.js常用API

## 3.1 HelloWorld

```javascript
//1.新建helloword.js
const foo = 'hello nodejs'
console.log(foo)

// 包含文件名称的全路径
console.log(__filename);
// 文件的所处的目录的绝对路径（不包含文件名称）
console.log(__dirname);

// 定时函数，用法与浏览器中的定时函数类似
var timer = setInterval(()=>{
        console.log(123);
},1000);

setTimeout(()=>{
    clearInterval(timer);
},4000);

// 在Node.js中没有window对象，但是有一个类似的对象global，访问全局成员的时候可以省略global
global.console.log(123456);

// argv是一个数组，默认情况下，前两项数据分别是：Node.js环境的路径；当前执行的js文件的全路径
// 从第三个参数开始表示命令行参数
console.log(process.argv);
// 打印当前系统的架构（64位或者32位）
console.log(process.arch);

//2.运行helloworld.js 
命令使用  node helloworld.js  ，会看到在命令窗口中输出hello nodejs

#注意：
1.文件名不要命名为node.js,文件名尽量避免使用中文
2.node.js中没有dom和bom，所以不要使用dom和bom操作的api，比如document、window之类的
```

## 3.2 文件操作

### 3.2.1 查看文件状态 fs.stat()

```javascript
const fs = require('fs');
//异步方法
fs.stat('./js',(err,stat) => {
    // 一般回调函数的第一个参数是错误对象，如果err为null,表示没有错误，否则表示报错了
    if(err) return;
    if(stat.isFile()){
       console.log('文件');
    }else if(stat.isDirectory()){
      console.log('目录');
    }
    console.log(stat);
    /*
     atime 文件访问时间
     ctime 文件的状态信息发生变化的时间（比如文件的权限）
     mtime 文件数据发生变化的时间
     birthtime 文件创建的时间
     */
    console.log(2);
});
console.log(3);

// 同步操作
console.log(1);
let ret = fs.statSync('./data.txt');
console.log(ret);
console.log(2);

# API方法中如果没有Sync，往往是同步方法，否则是异步方法
```

### 3.3.2 读取文件 fs.readFile()

```javascript
// 浏览器中的 JavaScript 是没有文件操作的能力的。但是 Node 中的 JavaScript 具有文件操作的能力

// fs 是 file-system 的简写，就是文件系统的意思。在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块
// 在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 。例如：fs.readFile 就是用来读取文件的

// 1. 使用 require 方法加载 fs 核心模块
var fs = require('fs')

// 2. 读取文件
/*
    第一个参数就是要读取的文件路径
    第二个参数是一个回调函数
        成功 (data 数据 ，error null)
        失败  (data undefined没有数据 ,error 错误对象)
*/
fs.readFile('./data/a.txt', function (error, data) {
  // <Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73 0d 0a>
  // 文件中存储的其实都是二进制数据 0 1。这里为什么看到的不是 0 和 1 呢？原因是二进制转为 16 进制了
  // 在这里就可以通过判断 error 来确认是否有错误发生
  if (error) {
    console.log('读取文件失败了')
  } else {
    console.log(data.toString())
  }
})
```

### 3.3.3 写入文件 fs.writeFile()

```javascript
var fs = require('fs')

/*
 第一个参数：文件路径
 第二个参数：文件内容
 第三个参数：回调函数
    成功：
      文件写入成功
      error 是 null
    失败：
      文件写入失败
      error 就是错误对象
*/
fs.writeFile('./data/你好.md', '大家好，给大家介绍一下，我是Node.js', function (error) {
  if (error) {
    console.log('写入失败')
  } else {
    console.log('写入成功了')
  }
})
```

### 3.3.4 文件流操作 stream

```javascript
const path = require('path');
const fs = require('fs');

let spath = path.join(__dirname,'./a.js');
let dpath = path.join(__dirname,'./a1.js');

//文件输入流
let readStream = fs.createReadStream(spath);
//文件输出流
let writeStream = fs.createWriteStream(dpath);

// 基于事件的处理方式
readStream.on('data',(chunk)=>{
     writeStream.write(chunk);
});

readStream.on('end',()=>{
     console.log('文件处理完成');
});


// pipe的作用直接把输入流和输出流  管道流
//fs.createReadStream(spath).pipe(fs.createWriteStream(dpath));
```

### 3.3.5 文件操作-promise

```javascript
let fs = require("fs");
const fsPromises = fs.promises;


fsPromises.stat("./tt")
.then(function(){
	console.log("tt目录已经存在");
},function(err){
	return fsPromises.mkdir("./tt");
})
.then(function(){
	console.log("创建目录成功");
	const data = new Uint8Array(Buffer.from('Node.js中文网'));
	return fsPromises.writeFile("./tt/bb.txt",data);
},function(err){
	console.log("创建目录失败")
})
.then(function(){
	console.log("写入信息成功")
},function(err){
	console.log("写入信息失败");
})
```

## 3.3 路径操作

### 3.3.1 基本操作

```javascript
/*
 路径操作
 */
const path = require('path');

// 获取路径的最后一部分
console.log(path.basename('/foo/bar/baz/asdf/quux.html'));
// 去掉后缀
console.log(path.basename('/foo/bar/baz/asdf/quux.html', '.html'));

// 获取路径
console.log(__dirname);
console.log(path.dirname('/abc/qqq/www/abc'));

// 获取扩展名称
console.log(path.extname('index.html'));

// 两个特殊属性
console.log(path.delimiter);//表示路径分隔符（windows是\ Linux是/）
console.log(path.sep);//环境变量分隔符(windows中使用; linux中使用:)
```

### 3.4.2 绝对路径和相对路径

```javascript
#1. 相对路径
//在读写文件的时候，./的含义是相对于执行node命令所处的路径
//比如在C:/code下执行 node app.js，./相对于的就是code目录
//比如在C下执行node  code/app.js，./相对于的就是C盘根目录
fs.readFile( './a.js', function (err, data) {
  if (err) {
    throw err
  }
  console.log(data.toString())
})

#2. 绝对路径
//总是拿到当前a.js的绝对路径
fs.readFile(path.join(__dirname, './a.js'), function (err, data) {
  if (err) {
    throw err
  }
  console.log(data.toString())
})

#3.结论：在服务器开发的时候，使用相对路径是不可靠的，尽量多使用绝对路径


# 关于路径：
在读写文件的时候，./的含义是相对于执行node命令所处的路径
../表示当前目录的上一级目录
如果这么写：../../表示当前目录的上上级目录
/表示根目录(也即本地根目录)
```

## 3.4 URL和对象的转换

### 3.4.1 url.parse和url.format

```javascript
const url = require('url');
// parse方法的作用就是把URL字符串转化为对象
let str = 'http://www.baidu.com/abc/qqq?flag=123&keyword=java';
let ret = url.parse(str,true);
console.log(ret.query.keyword);

// format的作用就是把对象转化为标准的URL字符串
let obj = {
   protocol: 'http:',
   slashes: true,
   auth: null,
   host: 'www.baidu.com',
   port: null,
   hostname: 'www.baidu.com',
   hash: null,
   search: '?flag=123&keyword=java',
   query: 'flag=123&keyword=java',
   pathname: '/abc/qqq',
   path: '/abc/qqq?flag=123&keyword=java',
   href: 'http://www.baidu.com/abc/qqq?flag=123&keyword=java' 
};
let ret1 = url.format(obj);
console.log(ret1);
```

### 3.4.2 querystring.parse和querystring.stringify

```javascript
// parse方法的作用就是把字符串转成对象
let param = 'username=lisi&password=123';
let param = 'foo=bar&abc=xyz&abc=123';
let obj = querystring.parse(param);
console.log(obj);

// stringify的作用就是把对象转成字符串
let obj1 = {
     flag : '123',
     abc : ['hello','hi']
}
let str1 = querystring.stringify(obj1);
console.log(str1);
```

## 3.5 目录操作

```javascript
/*
 目录操作
 1、创建目录
 fs.mkdir(path[, mode], callback)
 fs.mkdirSync(path[, mode])
 2、读取目录
 fs.readdir(path[, options], callback)
 fs.readdirSync(path[, options])
 3、删除目录
 fs.rmdir(path, callback)
 fs.rmdirSync(path)
 */

const path = require('path');
const fs = require('fs');
// 创建目录
fs.mkdir(path.join(__dirname,'abc'),(err)=>{
     console.log(err);
});

// 读取目录
fs.readdir(__dirname,(err,files)=>{
    files.forEach((item,index)=>{
        fs.stat(path.join(__dirname,item),(err,stat)=>{
             if(stat.isFile()){
                 console.log(item,'文件');
             }else if(stat.isDirectory()){
                 console.log(item,'目录');
             }
         });
     });
});

fs.stat("./tt",function(err,stats){
	//如果有错误说明tt目录不存在
	if (err) {
		//tt目录不存在我们就创建tt目录
		fs.mkdir("./tt",function(err){
			if (err) {
				console.log("目录创建错误");
				return;
			}

			//向tt目录下的bb.txt中写文件
			fs.writeFile("./tt/bb.txt",data,function(err){
				if(err){
					console.log(err)
					return;
				}
				console.log("tt写文件成功");
			})
		})
	}
})


// 删除目录
fs.rmdir(path.join(__dirname,'abc'),(err)=>{
     console.log(err);
});

//如果文件夹里面有其他文件，则该文件夹不可以直接被删除
//递归删除文件/文件夹
function deleteall(path) {
	var files = [];
	//1.判断文件或者文件夹是否存在
	if(fs.existsSync(path)) {
		//如果存在，则读取文件夹信息
		files = fs.readdirSync(path);
		//遍历每一个文件
		files.forEach(function(file, index) {
			var curPath = path + "/" + file;
			//如果是目录 删除目录
			if(fs.statSync(curPath).isDirectory()) { 
				deleteall(curPath);
			} else { 
				//删除文件
				fs.unlinkSync(curPath);
			}
		});
		fs.rmdirSync(path);
	}
};
```

## 3.6 node中的REPL

REPL就类似于浏览器中的控制台，我们可以在cmd控制台中输入指定信息进行调试。
REPL：read  eval  print  loop     读取用户输入--->执行用户输入--->打印用户输入---->等待下一次用户输入

```
REPL用法：
	1.在任意目录下打开命令行，输入指令node
	2.然后就可以使用node控制台了
	3.在REPL环境中，_表示最后一次执行结果; .exit 可以退出REPL环境
```

![1543826304858](assets/1543826304858.png)

# 4.Node和HTTP 

## 4.1 HTTP协议介绍

### 4.1.1 定义

	HTTP（HyperText Transfer Protocol，超文本传输协议）最早就是计算机与计算机之间沟通的一种标准协议，这种协议限制了通讯内容的格式以及各项内容的含义。默认使用80端口。最新版本是HTTP 2.0，目前是用最广泛的是HTTP 1.1。
	
	HTTP协议： 对客户端和服务器端之间数据传输的格式规范。

![](media/b1.png)

	随着时代的发展，技术的变迁，这种协议现在广泛的应用在各种领域，也不仅仅局限于计算机与计算机之间，手机、电视等各种智能设备很多时候都在使用这种协议通讯，所以一般现在称 HTTP 为端与端之间的通讯协议。
	
	Web 属于 B/S 架构的应用软件，在 B/S 架构中，浏览器与服务器沟通的协议就是 HTTP 协议，作为一个合格的Web 开发者，了解 HTTP 协议中约定的内容是一门必修课。

### 4.1.2 HTTP协议约定内容

```
请求 / 响应报文格式
请求方法 —— GET / POST
响应状态 —— 200 / 404 / 302 / 304
预设的请求 / 响应头
```

### 4.1.3 HTTP协议工作流程

```
1. 客户端通过随机端口与服务端某个固定端口（一般为80）建立连接 三次握手
2. 客户端通过这个连接发送请求到服务端（这里的请求是名词）
3. 服务端监听端口得到的客户端发送过来的请求
4. 服务端通过连接响应给客户端状态和内容
```

	要求：接下来的一个月，每次上网打开任何一个页面时都要能够脑补这个画面，默念这个流程。

![](media/d10.png)

### 4.1.4 HTTP协议的三次握手

	HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。
	
	下图所示TCP连接的三次握手。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之前并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。

![1539259434258](assets/1539259434258.png)

### 4.1.5 HTTP协议的特点

	无状态：同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求来自同一个客户端。这意味着，每一个请求的是独立的，任何两个请求之间无任何记忆关系。如果服务端处理一个请求需要前面的信息，则该信息必须重传。

```javascript
//除了上面无状态这个特点，还有几个其他小特点：
1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
3. 在HTTP/1.1之前，使用非持续连接，客户端（浏览器）和服务器每次连接只处理一个请求。服务器处理完客户端的请求，对客户端做出应答后，即断开连接。
   HTTP/1.1开始，默认开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
```

## 4.2 HTTP协议核心概念

### 4.2.1  请求报文

![](media/b3.png)

![](media/b4.png)

1. 请求行 

```
GET /demo.php HTTP/1.1
请求方式 + 空格 + 请求路径 + 空格 + HTTP 协议版本


GET：字面意思：拿，获取
POST：发送
```

![](media/b8.png)

```javascript
GET请求无害：get是等幂的，无论执行多少遍不影响最终的结果。
POST是不等幂的，每次post调用都会创建新的资源。

//IE下GET请求的缓存(POST请求无缓存)：
//Ajax使用GET方式发送请求时，在IE下会产生缓存。很多情况下，ajax都会获取实时数据，如果存在缓存问题，就会影响数据真实性。可使用以下两种方式清除缓存：
1.URL随机后缀：在get请求时增加一个随机后缀，用来区分每一次访问的URL地址
    $.ajax({
        type: "GET",
        url: "http://localhost/index.php?s="+Math.random(),
        data: null,
        success: function(data){
            console.log(data);      
        }
    });	
 		
    //在jquery中可以通过$.ajaxSetup({cache:false})去除get请求缓存 	
	$.ajaxSetup({cache:false});
	$("#box").click(function(){
		$.ajax({
             type: "GET",
             url: "http://localhost/index.php",
             data: null,
             success: function(data){
                 console.log(data);      
             }
         });
	})
```

2. 请求头

     客户端想要告诉服务端的一些额外信息，以下为常见的请求头：

![](media/b6.png)

3. 请求体

     这次请求客户端想要发送给服务端的数据正文，只有POST请求才有请求体

### 4.2.2 响应报文

![](media/b5.png)



1. 状态行

```
HTTP/1.1 200 OK
HTTP 协议版本 + 空格 + 状态码 + 空格 + 状态描述
```

2. 响应头

      服务端想要告诉客户端的一些额外信息，常见的有以下：

![](media/b7.png)

	请求服务端想要返回给客户端的数据正文，一般返回的都是 HTML，也可以返回 JavaScript 或者 CSS（需要修改响应头中的响应类型）。

### 4.2.3 响应状态码

> http://www.w3school.com.cn/tags/html_ref_httpmessages.asp

	状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

```
1xx：指示信息 —— 表示请求已接收，继续处理。
2xx：成功 —— 表示请求已被成功接收、理解、接受。
3xx：重定向 —— 要完成请求必须进行更进一步的操作。
4xx：客户端错误 —— 请求有语法错误或请求无法实现。
5xx：服务器端错误 —— 服务器未能实现合法的请求
```

	常见状态代码、状态描述的说明如下

```php
200 OK：客户端请求成功。
/*客户端错误*/
400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
403 Forbidden：服务器收到请求，但是拒绝提供服务。
404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
/*服务器错误*/
500 Internal Server Error：服务器发生不可预期的错误。
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。
```

### 4.2.4 HTTPS

```javascript
#HTTPS协议：简单来说，可以理解为安全版的HTTP协议，基于TCP/IP协议和SSL/TLS协议之上的应用层协议。默认端口443。

#HTTP协议和HTTPS协议的区别
1.HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如密码等。
2.HTTPS为安全套接字层超文本传输协议。HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 

#HTTPS和HTTP的区别主要为以下四点：
1.https协议需要到ca申请证书，一般免费证书很少，需要交费。
2.http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
```

## 4.3 使用Node搭建HTTP服务器

传统的动态网站开发需要应用软件：

> PHP ： Apache + php模块
> java ：Tomcat 、Weblogic
> Node.js  : 不需要应用软件（可以自己实现）

### 4.3.1 基本使用

```javascript
// 在 Node 中专门提供了一个核心模块：http。http 这个模块的职责就是帮你创建编写服务器的

const http = require('http');
// 1. 创建服务器实例对象，提供对数据的服务
// let server = http.createServer();
// 2. 绑定请求事件
// server.on('request',(req,res)=>{
//     res.end('hello');
// });
// 3. 监听端口
// server.listen(3000);
// 4. 访问web服务器
 // 4.1 node  http.js 启动web服务器。按住ctrl+c可以停止web服务
//  4.2 通过 http://127.0.0.1:3000/访问web服务器


# 使用ES6的语法简写如下：
http.createServer((req,res)=>{
    res.end('ok');
}).listen(3000,'192.168.0.106',()=>{
    console.log('running...');
});
```

### 4.3.2 根据请求处理响应

```javascript
# 注意：之前的web服务器在开启一个新的demo的时候需要重启web服务器

/*
    处理请求路径的分发
    1、req对象是http.IncomingMessage的实例对象，请求对象可以用来获取客户端的一些请求信息，例如请求路径
    2、res对象是http.ServerResponse的实例对象， 响应对象可以用来给客户端发送响应消息
*/
const http = require('http');
http.createServer((req,res)=>{
    // req.url可以获取URL中的路径（端口之后部分）
    // http://127.0.0.1:3000/ /
    // http://127.0.0.1:3000/a /a
    // http://127.0.0.1:3000/foo/b /foo/b
    console.log('收到客户端的请求了，请求路径是：' + req.url)
    console.log('请求我的客户端的地址是：', req.socket.remoteAddress, req.socket.remotePort);
    
    if(req.url.startsWith('/index')){
        // write向客户端响应内容,可以写多次
        res.write('hello');
        res.write('hi');
        res.write('nihao');
        // end方法用来完成响应，只能执行一次
        res.end();
    }else if(req.url.startsWith('/about')){
        res.end('about');
    }else{
        res.end('no content');
    }
}).listen(3000,'192.168.0.106',()=>{
    console.log('running...');
});
```

### 4.3.3 响应完整页面

```javascript
const http = require('http');
const path = require('path');
const fs = require('fs');

// 根据路径读取文件的内容，并且响应到浏览器端
let readFile = (url,res) => {
    fs.readFile(path.join(__dirname,'www',url),'utf8',(err,fileContent)=>{
        if(err){
            res.end('server error');
        }else{
            res.end(fileContent);
        }
    });
}

http.createServer((req,res)=>{
    // 处理路径的分发
    if(req.url.startsWith('/index')){
        readFile('index.html',res);
    }else if(req.url.startsWith('/about')){
        readFile('about.html',res);
    }else if(req.url.startsWith('/list')){
        readFile('list.html',res);
    }else{
        // 设置响应的类型和编码
        res.writeHead(200,{
            'Content-Type':'text/plain; charset=utf8'
        });
        res.end('页面被狗狗叼走了');
    }
}).listen(3000,'192.168.0.106',()=>{
    console.log('running...');
});
```

### 4.3.4 设置响应体

```javascript
//MIME type 指的是文件类型， 像 text/css ， text/html ， text/plain ， applcation/javascript

const http = require('http');
const path = require('path');
const fs = require('fs');
const mime = require('./mime.json');

  /*
   浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析，中文操作系统默认是 gbk
  
   在 http 协议中，Content-Type 就是用来告知对方我给你发送的数据内容是什么类型
     res.setHeader('Content-Type', 'text/plain; charset=utf-8')
     res.end('hello 世界')
  */
http.createServer((req,res)=>{
    fs.readFile(path.join(__dirname,'www',req.url),(err,fileContent)=>{
        if(err){
            // 没有找到对应文件
            res.writeHead(404,{
                'Content-Type':'text/plain; charset=utf8'
            });
            res.end('页面被狗狗叼走了');
        }else{
            let dtype = 'text/html';
            // 获取请求文件的后缀
            let ext = path.extname(req.url);
            // 从mime.json文件中获取标准的响应格式
            if(mime[ext]){
                dtype = mime[ext];
            }
            // 如果响应的内容是文本，就设置成utf8编码
            if(dtype.startsWith('text')){
                dtype += '; charset=utf8'
            }
            // 设置响应头信息
            res.writeHead(200,{
                'Content-Type':dtype
            });
            res.end(fileContent);
        }
    });
}).listen(3000,()=>{
    console.log('running...');
});


//如果是css和js文件，对应的css和js文件需要在页面被引用后效果才能显现
```

### 4.3.5 重定向

```javascript
// 1. 导入http模块
var http = require('http');
// 2. 导入文件模块
var fs = require('fs');
// 3. 导入路径模块
var path = require('path');
// 4. 创建服务器
var server = http.createServer();
// 5. 监听客户端请求
server.on('request', function (req,res) {
    console.log(req.url);
    if (req.url === '/index') {
        // 通过响应头来实现服务端重定向
        res.writeHead(302,{
            'Location': 'http://127.0.0.1:3000/login'
        })   
        res.end();
    } else if (req.url === '/login') {
        fs.readFile(path.join(__dirname,'login.html'),function (err,data) {
            if (err) {
                throw err;
            }
            res.end(data)
        })
    }
})
// 6. 启用服务器
server.listen(3000,function () { console.log('启用成功'); })


# 关于重定向：
301 是永久重定向，浏览器会记住，本来是去请求a.html，服务器重定向到b.html，下次在去请求a.html的时候由于浏览器记住了状态，会直接来到b.html页面

302 是临时重定向， 浏览器不会记住，本来是去请求a.html，服务器重定向到b.html，下次在去请求a.html的时候还是会经历服务器重定向的过程
```

## 4.4 参数的处理

### 4.4.1 GET请求参数

```javascript
const http = require('http');
const path = require('path');
const url = require('url');

http.createServer((req,res)=>{
    let obj = url.parse(req.url,true);
    //获取get请求参数
    res.end(obj.query.username + '=========' + obj.query.password);
}).listen(3000,()=>{
    console.log('running....');
})
```

### 4.4.2 POST请求参数

```javascript
const querystring = require('querystring');
const http = require('http');

http.createServer((req,res)=>{
    if(req.url.startsWith('/login')){
        let pdata = '';
        //POST请求使用req.on方法处理请求参数
        req.on('data',(chunk)=>{
            // 每次获取一部分数据
            pdata += chunk;
        });

        req.on('end',()=>{
            // 这里才能得到完整的数据
            console.log(pdata);
            let obj = querystring.parse(pdata);
            console.log(obj);
        });
    }
}).listen(3000,()=>{
    console.log('running...');
})
```

# 5.Node模块系统的使用

## 5.1 node.js中模块的分类

	Node.js中模块的分类：系统核心模块、用户自定义模块、第三方模块(arttemplate)

## 5.2 系统核心模块

	Node为javascript提供了很多服务器级别的API，这些API都被封装到了一个具名的模块中。

```javascript
//例如文件操作的fs模块，http服务器的模块，path路径操作的模块，os操作的系统模块。
- fs 文件操作
- http 网络操作
- path 路径操作
- querystring 查询参数解析
- url url解析
- ......
```

	以后只要需要使用这些模块的功能，都需要通过require引入：

```javascript
//http://nodejs.cn/api/os.html

var os = require('os')
// 用来操作路径的
var path = require('path')
// 获取当前机器的 CPU 信息
console.log(os.cpus())
// memory 内存
console.log(os.totalmem())

// 获取一个路径中的扩展名部分
// extname extension name
console.log(path.extname('c:/a/b/c/d/hello.txt'))
```

## 5.3 用户自定义模块

### 5.3.1 模块的加载

```javascript
#1.  a.js
var foo = 'aaa'
console.log('a start')
function add(x, y) {
  	return x + y
}

// Error: Cannot find module 'b'    报错，直接当成核心模块引入
// require('b')   

// 可以
// require('./b.js')
// 推荐：可以省略后缀名
require('./b')

console.log('a end')
console.log('foo 的值是：', foo)    //这里面foo的值仍然是当前a.js中的值，不会是b.js中的值

#2.  b.js
console.log('b start')
// console.log(add(10, 20))   报错，找不到add方法
var foo = 'bbb'
require('./c.js')
console.log('b end')

#3.  c.js
console.log('ccc')

#4. 注意点：
1.模块作用域：模块外部访问不到内部的信息，模块内部也访问不到外部的信息
2.require("./b.js") 中.js可以省略。但是前面的./不可以省略，如果省略会当做核心模块引入
   推荐使用require("./b")。
```

### 5.3.2 模块的导出

```javascript
#1.   b.js
//    在每个文件模块中都提供了一个对象：exports。 exports 默认是一个空对象
//    我们可以将需要被外部访问的成员挂载到这个 exports 对象中
var foo = 'bbb'

// console.log(exports)
exports.foo = 'hello'
exports.add = function (x, y) {
 	 return x + y
}

#2. a.js
var bExports = require('./b')
var fs = require('fs')

console.log(bExports.foo)
console.log(bExports.add(10, 30))
console.log(bExports.age)

fs.readFile('./a.js', function (err, data) {
      if (err) {
        console.log('读取文件失败')
      } else {
        console.log(data.toString())
      }
})
```

# 6.模块化规范

```javascript
//1.传统非模块化开发有如下缺点：命名冲突    文件依赖 
//2.模块化  = 文件作用域+通信规则(模块之间的通信)
//3.标准的前端模块化规范:
1.AMD   ----->   require.js
2.CMD    ----->   sea.js
//4.标准的服务端模块化规范：
1.CommonJS    ------> Node.js
```

![1543897092705](assets\1543897092705.png)

## 6.1 为什么要使用模块

```javascript
#1. test.html
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="js/module1.js"></script>
    <script src="js/module2.js"></script>
</head>
<body>

</body>
</html>
<script>
    var module=function(){
        console.log('I am module3');
    };
    module();
</script>

#2.module1.js
var module=function(){
    cosonle.log('I am module1.js');
}
var a = 1;

#3.module2.js
var module=function(){
    console.log("I am module2.js");
    console.log(a);
}

#4. 上面代码的问题
#4.1 加载js的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长
#4.2 js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。
#4.3 多个js文件中声明了同名的变量的时候，会出现命名污染的问题
```

## 6.2 AMD

### 6.2.1 AMD模块规范

```javascript
AMD ： Asynchronous Module Definition。AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出
#1.定义
define(id?,dependencies?,factory);
    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.
    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量
    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.
    - 默认情况下文件名即为模块名

#2.导入
require([dependencies],function(){});
    - 第一个参数是一个数组,表示所依赖的模块
    - 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块
```

### 6.2.2 AMD模块案例

```javascript
#1. test.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
	//引入require.js
    <script src="js/require.js"></script>

    <script>
        //模块的配置
        require.config({
            //baseUrl: "js",
            paths: {
                calculator: "js/calculator"
            }
        });

		//引入calculator模块,function中的calculator参数表示模块对象
        require(['calculator'], function (calculator){
            alert(calculator.add("2","3"));
        });
    </script>
</head>
<body>

</body>
</html>



#2.calculator.js
require.config({
    paths: {
        convertor: "js/convertor"
    }
});
//定义calculator模块，该模块依赖于convertor模块，function中的convertor表示convertor模块对象
define("calculator", ['convertor'], function (convertor) {
    var add = function(a,b) {
        return convertor.convertToNumber(a)+convertor.convertToNumber(b);
    }
    //导出模块方式一：直接return
    return {
        add: add
    };
    
    /*
    //导出模块方式二：使用 module.exports
    module.exports = {
        add : add
    }
    
    //导出模块方式三：使用 exports. xx         注意，不能直接给exports赋值，比如exports = {}
    exports. add = add;
    */
});


#3.convertor.js
//定义convertor模块
define("convertor", [], function() {
    var convertToNumber = function convertToNumber(input){
        return parseFloat(input);
    }
    return {
        convertToNumber: convertToNumber
    };
});
```

## 6.3 CMD

### 6.3.1 CMD模块规范

```javascript
CMD 即Common Module Definition通用模块定义,CMD规范是国内发展出来的

#1. 定义
define(id?,d?,factory)
- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id
- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖
- factory :函数   function(require,exports,module)
        require 是一个方法,用来获取其他模块提供的接口
        exports 是一个对象,用来向外提供模块接口
        module 是一个对象,上面存储了与当前模块相关联的一些属性和方法

#2. 使用
seajs.use('mymodel.js',function(mymodel){
});
```

### 6.3.2 CMD模块案例

```javascript
#1. test.html
<head>
    <meta charset="UTF-8">
    <title>Seajs体验</title>
    <script src="js2/sea.js"></script>
    <script>
        // 在seajs中模块的引入需要相对路径完整写法
        seajs.use('./js2/calculator.js', function(calculator) {
            //calculator其实就是calculator.js中的exports对象
            var value = calculator.add("1", "11");
            console.log(value);
        });
    </script>
</head>


#2. calculator.js
// 定义一个模块，遵循Seajs的写法
define(function(require, exports, module) {
    // 此处是模块的私有空间
    // 载入convertor.js模块
    var convertor = require('./convertor.js');

    // 定义模块的私有成员
    function add(a, b) {
        return convertor.convertToNumber(a) + convertor.convertToNumber(b);
    }
    // 暴露模块的公共成员
    exports.add = add;
    
    /*
    导出模块仍然三种方式
    module.exports
    exports.xxx
    return
    */
});


#3.convertor.js
define(function(require, exports, module) {
    // 公开一些转换逻辑
    exports.convertToNumber = function(input) {
        return parseFloat(input);
    }
});
```

## 6.4 AMD和CMD区别

```javascript
1.CMD 推崇依赖就近;AMD 推崇依赖前置
2.CMD 是延迟执行,懒加载;AMD 是提前执行
3.CMD性能好,因为只有用户需要的时候才执行;AMD用户体验好,因为没有延迟,依赖模块提前执行了

# 总结：AMD和CMD最大的区别是对依赖模块的执行时机处理不同,注意不是加载的时机或者方式不同。两者都是异步加载模块。

//AMD
define(['./a','./b'],function(a,b){
      a.doSomething()
      b.dosomething()
})

//CMD
define(function(require,exports,module){
      var a=require('./a')
      a.doSomethimg()
      var b=require('./b')
      b.doSomething()
})
```

## 6.5 CommonJS

### 6.5.1 CommonJS模块化规范

```javascript
Node.js使用了CommonJS模块化规范
 
//1.加载模块
var module = require("模块名称");

作用：执行被加载模块中的代码
          得到被加载模块中的exports对象
          
//2.导出模块
对于希望被其他模块加载的成员，我们可以将它挂载到exports对象中
```

```javascript
#01.js
require("./test.js");
console.log("我是01.js，我认识a么？" + a);//访问不到，会报错

#test.js
var a = 100;
console.log("我是test.js文件，我认识a，值是" + a);

#CommonJS中 一个文件就是一个模块，拥有单独的作用域；
```

![1554954010643](assets\1554954010643.png)

### 6.5.2 导出单个和多个成员

```javascript
//1.导出单个成员
var foo = 'bar'
function add(x, y) {
  return x + y
}
exports.foo = 'hello'
exports.add = add

//2.导出多个成员
// 如果一个模块需要直接导出某个成员，而非挂载的方式
module.exports = {
  add: function () {
    return x + y
  },
  str: 'hello'
}

# 导出单个成员和多个成员的原理：
	为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：
	var exports = module.exports，在对外输出时，可以给exports对象添加方法
    PS：exports不能直接赋值（因为这样就切断了exports和module.exports的联系）;
```

### 6.5.3 模块的缓存

```javascript
//1.a.js
var fn = require('./b')
var fn = require('./b')
console.log(fn)

//2.b.js
console.log('b.js 被加载了')

//可以发现b.js指打印了一次

# 所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的;
```

### 6.5.4 require加载规则

```javascript
//1. 非路径形式的模块标识
   require('fs')
   require('http')

//2. 路径形式的模块：
  ./  当前目录，不可省略
  ../ 上一级目录，不可省略
  /   表示当前磁盘根目录，几乎不用
  d:/a/foo.js   几乎不用

  `.js 后缀名可以省略`
  require('./foo.js')

//3.第三方模块
    凡是第三方模块都必须通过 npm 来下载
    使用的时候就可以通过 require('包名') 的方式来进行加载才可以使用
    
    var template = require('art-template') 查找步骤如下：
      a) 先找到当前文件所处目录中的 node_modules 目录
      b) node_modules/art-template.js 或者art-template.json 或者art-template.node
      c) 找到node_modules/art-template包
      d) 找到node_modules/art-template/package.json 文件中的 main 属性, main 属性中就记录了 art-template 的入口模块
      e) 然后加载使用这个第三方包， 实际上最终加载的还是文件
	  f) 如果 package.json 文件不存在或者 main 指定的入口模块是也没有，则 node 会自动找该目录下的 index.js，也就是说 index.js 会作为一个默认备选项
      g) 如果以上所有任何一个条件都不成立，则会进入上一级目录中的 node_modules 目录查找package.json或者index.js
      h) 如果上一级还没有，则继续往上上一级查找
      i) 如果直到当前磁盘根目录还找不到，最后报错： can not find module xxx
            
      
 //深入Node.js的模块机制 : http://www.cnblogs.com/takemybreathaway/articles/9757342.html
       
       
 # 注意：如果是下面这种目录结构，main.js将无法访问到node_modules
 blog
      -- a
          --- node_modules
      -- b
          //无法访问a目录下的node_modules，只能查找到当前目录和当前目录的父级目录下的node_modules
          //所以一般情况下，node_modules放在项目根目录下
          --- main.js
```

### 6.5.5  同步加载与异步函数

#### a) 同步加载

```javascript
require：CommonJS中的require是同步加载的

# CommonJS采用同步方式加载模块，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是浏览器不能同步加载模块，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器会处于"假死"状态。
```

#### b) 异步函数

```javascript
#1.a.jx
require("./b.js");
console.log("你好，我是a.js文件里面的语句");
```

```javascript
#2.b.js
var fs = require("fs");
console.log("你好，我是b.js文件里面的语句");
fs.readFile("./aa.txt",function(err,data){
	console.log("你好，我是b.js回调函数里面的语句");
});

#3.node a.js

//require的文件中如果有异步语句，此时nodejs不会死等它结束，会返回执行主文件中的程序，如果文件读取完毕，执行回调函数
```

	打印顺序如下：

![1554953361788](assets\1554953361788.png)

# 7.包管理

## 7.1 包说明文件 

### 7.1.1 package.json

```javascript
//1.一般情况下，每个项目都会有一个package.json用来记录当前项目所有依赖的包
npm install art-template --save
上面的命令会自动将当前安装的art-template添加到package.json文件中，表示当前项目依赖art-template

//2.我们还可以通过npm init 命令来初始化package.json
`package.json`
{
  "name": "blog",
  "version": "0.0.1",
  "description": "测试",
  "main": "main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "mazg",
  "license": "ISC",
  "dependencies": {
    "jquery": "^3.3.1"
  }
}
```

![1543907462062](assets\1543907462062.png)

### 7.1.2 package-lock.json

```javascript
package-lock.json有两个作用：
1.记录package.json文件中所有第三方组件的依赖信息，方便下次再去下载
2.锁定第三方组件的版本信息，下次再去下载的时候会去下载指定的版本信息

 //package.json中的^表示只要express版本在4.16.4之上的版本都可以
 "dependencies": {
    "express": "^4.16.4"
  }
  
  //package-lock.json 当这个文件存在的时候，就固定住了express的版本，下次再去下载的时候只会去下载该版本
  "express": {
      "version": "4.16.4",
      "resolved": "http://registry.npm.taobao.org/express/download/express-4.16.4.tgz",
      .....
    }
```

## 7.2 NPM

### 7.2.1 介绍

```javascript
官网：https://www.npmjs.com/
我们下载的第三方包都是从这个网站下载下来的

NPM是Node.js下的一个包管理工具，只要安装了node就会自带NPM
```

### 7.2.2 NPM常用命令：

```
npm  -version                                       查看npm版本
npm  init
npm  init -y                                            跳过向导，快速生成
npm  install                                           找到package.json中的依赖项，一次性安装依赖  
npm  install  包名1  包名2   包名3
npm  install  包名  --save                      向生产环境添加依赖
npm  install  包名  --save-dev              向开发环境添加依赖，开发的时候用到的工具，比如babel\webpack\gulp等
npm  install  包名  --g                           全局安装
npm  uninstall  包名
npm  uninstall  包名  --save
npm  update 包名
npm  help                                              帮助
npm  install  help                                   查看具体某个命令的帮助
npm  run
```

### 7.2.3 NPM翻墙

```javascript
http://npm.taobao.org/     淘宝开发团队将NPM在国内做了一个备份
//1.安装cnpm
npm install cnpm -g           安装cnpm
cnpm install jquery             使用cnpm安装jquery(淘宝镜像)

//2.修改npm镜像源地址
npm install bootstrap --save --registry=https://registry.npm.taobao.org

npm config set registry https://registry.npm.taobao.org
npm config list                    查看npm的配置文件列表
```

	什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候我们可以在国内创建一个和官网完全一样的NPM服务器，只不过数据都是从人家那里拿过来的，除此之外使用方式完全一样；

### 7.2.4 NRM使用

	默认情况下，NPM会自动从registry.npmjs.org网站下载资源，为了解决这个问题，我们需要修改NPM的镜像源。如果我们想快速方便的切换镜像源，我们可以使用NRM。
	
	作用:提供一些常用的NPM包镜像地址，让我们快速的切换安装包时候的服务器地址

```javascript
npm install nrm -g
nrm ls                     列出所有镜像源
nrm use taobao     使用某个镜像源
```

### 7.2.5 YARN工具基本使用

```javascript
yarn也是一个包管理工具

npm install -g yarn     安装yarn  
yarn  init                     初始化
yarn install                  安装所有依赖
yar add jquery        
yarn add jquery --dev
yarn  remove  jquery
yarn upgrade jquery    更新包
yarn config set registry url   设置镜像
yarn run
```
